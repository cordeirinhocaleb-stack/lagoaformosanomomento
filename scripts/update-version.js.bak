
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const rootDir = path.join(__dirname, '..');
const packageJsonPath = path.join(rootDir, 'package.json');
const versionMdPath = path.join(rootDir, 'VERSION.md');

// Ler argumentos: type [build|patch|minor|major] description category
const args = process.argv.slice(2);
const updateType = args[0] || 'build'; // Default to build increment
const description = args[1] || 'Atualiza√ß√£o de desenvolvimento';
const category = args[2] || 'Dev';

// Fun√ß√£o para parsear SemVer manual (simples)
// Suporta: 1.2.3 ou 1.2.3+45
const parseVersion = (v) => {
    const [base, build] = v.split('+');
    const [major, minor, patch] = base.split('.').map(Number);
    return { major, minor, patch, build: build ? parseInt(build) : 0 };
};

console.log(`üì¶ Lendo package.json...`);
const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
const current = parseVersion(packageJson.version);

let newVersion = '';
let displayVersion = '';

if (updateType === 'build') {
    // Incrementa apenas o n√∫mero de build (mant√©m base)
    // Ex: 1.212 -> 1.212+1
    // Ex: 1.212+5 -> 1.212+6
    const newBuild = current.build + 1;
    newVersion = `${current.major}.${current.minor}.${current.patch}+${newBuild}`;
    displayVersion = `${current.major}.${current.minor}.${current.patch} (Build ${newBuild})`;

} else if (updateType === 'patch') {
    // Incrementa patch e zera build (Release)
    // Ex: 1.212+5 -> 1.213
    newVersion = `${current.major}.${current.minor}.${current.patch + 1}`;
    displayVersion = newVersion; // Release limpa

} else if (updateType === 'minor') {
    newVersion = `${current.major}.${current.minor + 1}.0`;
    displayVersion = newVersion;

} else if (updateType === 'major') {
    newVersion = `${current.major + 1}.0.0`;
    displayVersion = newVersion;

} else {
    // Caso o usu√°rio passe uma vers√£o manual espec√≠fica (fallback)
    if (updateType.includes('.')) {
        newVersion = updateType;
        displayVersion = updateType;
    } else {
        console.error('‚ùå Tipo inv√°lido. Use: build, patch, minor, major ou x.y.z');
        process.exit(1);
    }
}

// 1. Atualizar package.json
console.log(`üîÑ Atualizando de ${packageJson.version} para ${newVersion}...`);
packageJson.version = newVersion;
fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2) + '\n');

// 2. Atualizar VERSION.md
console.log(`üìù Atualizando VERSION.md...`);
let versionContent = fs.readFileSync(versionMdPath, 'utf8');

const now = new Date();
const dateStr = now.toLocaleDateString('pt-BR');
const timeStr = now.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
const ref = dateStr.replace(/\//g, '') + timeStr.replace(':', '');

// Se for build, agrupa ou cria entrada menor?
// Para simplificar, cria entrada normal, mas indicando Build.
const newEntry = `
## ${displayVersion} - ${dateStr} ${timeStr} (Ref: ${ref})
- **${category}:** ${description}
`;

if (versionContent.includes('## Hist√≥rico de Vers√µes')) {
    versionContent = versionContent.replace('## Hist√≥rico de Vers√µes', '## Hist√≥rico de Vers√µes' + newEntry);
} else {
    versionContent = newEntry + versionContent;
}

fs.writeFileSync(versionMdPath, versionContent);


// 3. Gerar JSON estruturado para o Frontend (ChangelogModal)
console.log(`üìä Gerando config/changelog.json...`);
const lines = versionContent.split('\n');
const changelog = [];
let currentVersion = null;

const categoryMap = {
    'Feature': 'feature', 'Novidade': 'feature', 'Melhoria': 'improvement',
    'Improvement': 'improvement', 'Fix': 'fix', 'Bugfix': 'fix', 'Security': 'fix',
    'Ajuste': 'fix', 'Seguran√ßa': 'fix', 'Manuten√ß√£o': 'fix'
};

lines.forEach(line => {
    // Match Headers: ## 1.212 (Build 1) - 06/01/2026...
    const versionMatch = line.match(/^##\s+(.+?)\s+-\s+(\d{2}\/\d{2}\/\d{4})/);
    if (versionMatch) {
        currentVersion = {
            version: versionMatch[1],
            date: versionMatch[2],
            items: []
        };
        changelog.push(currentVersion);
        return;
    }

    // Match Items: - **Category:** Description
    if (currentVersion && line.trim().startsWith('-')) {
        const itemMatch = line.match(/-\s*\*\*(.+?):\*\*\s*(.+)/);
        if (itemMatch) {
            const rawCat = itemMatch[1].trim();
            const desc = itemMatch[2].trim();

            // Map category or default to 'improvement'
            let catType = 'improvement';
            for (const key in categoryMap) {
                if (rawCat.includes(key)) catType = categoryMap[key];
            }

            currentVersion.items.push({
                category: catType,
                title: rawCat,
                description: desc
            });
        }
    }
});

const configDir = path.join(rootDir, 'config');
if (!fs.existsSync(configDir)) fs.mkdirSync(configDir);

fs.writeFileSync(
    path.join(configDir, 'changelog.json'),
    JSON.stringify(changelog, null, 2)
);

console.log(`‚úÖ Sucesso! Vers√£o: ${displayVersion}`);
console.log(`   Changelog JSON atualizado com ${changelog.length} vers√µes.`);
console.log(`   Para release p√∫blica, rode: npm run bump patch "Descri√ß√£o" "Release"`);
