#!/usr/bin/env python3
"""
Pentesting Agent - Agente de Testes de Penetra칞칚o
Respons치vel por executar testes de seguran칞a automatizados

丘멆잺 USO 칄TICO OBRIGAT칍RIO - Apenas em projetos autorizados
"""

import json
import sys
import argparse
from typing import List, Dict, Any
from datetime import datetime
import os

class PentestingAgent:
    def __init__(self, target_url: str, memory_path: str = ".agents/memory/pentesting-agent"):
        self.target = target_url
        self.memory_path = memory_path
        self.results = []
        self.vulnerability_db = self.load_vulnerability_db()
        self.ensure_memory_structure()

    def ensure_memory_structure(self):
        """Garante que a estrutura de mem칩ria existe"""
        os.makedirs(self.memory_path, exist_ok=True)
        
        # Criar arquivos de mem칩ria se n칚o existirem
        for file in ['successes.json', 'failures.json', 'learnings.json']:
            filepath = os.path.join(self.memory_path, file)
            if not os.path.exists(filepath):
                with open(filepath, 'w') as f:
                    json.dump([], f)

    def load_vulnerability_db(self) -> Dict[str, Any]:
        """Carrega banco de dados de vulnerabilidades"""
        db_path = os.path.join(os.path.dirname(__file__), 'vulnerability-db.json')
        try:
            with open(db_path, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            return self.get_default_vulnerability_db()

    def get_default_vulnerability_db(self) -> Dict[str, Any]:
        """Retorna banco de dados padr칚o de vulnerabilidades"""
        return {
            "sql_injection": {
                "severity": "CRITICAL",
                "owasp_id": "A03:2021",
                "category": "Injection",
                "payloads": [
                    "' OR '1'='1",
                    "'; DROP TABLE users--",
                    "' UNION SELECT NULL--",
                    "admin' --",
                    "' OR 1=1--"
                ],
                "detection": "Error messages, data leakage, unauthorized access",
                "remediation": "Use prepared statements, parameterized queries, ORM"
            },
            "xss": {
                "severity": "HIGH",
                "owasp_id": "A03:2021",
                "category": "Injection",
                "payloads": [
                    "<script>alert('XSS')</script>",
                    "<img src=x onerror=alert('XSS')>",
                    "javascript:alert('XSS')",
                    "<svg onload=alert('XSS')>",
                    "'-alert('XSS')-'"
                ],
                "detection": "Script execution, DOM manipulation",
                "remediation": "Sanitize inputs, use DOMPurify, Content Security Policy"
            },
            "csrf": {
                "severity": "HIGH",
                "owasp_id": "A01:2021",
                "category": "Broken Access Control",
                "detection": "Missing CSRF tokens, predictable tokens",
                "remediation": "Implement CSRF tokens, SameSite cookies"
            },
            "weak_passwords": {
                "severity": "CRITICAL",
                "owasp_id": "A07:2021",
                "category": "Identification and Authentication Failures",
                "common_passwords": [
                    "123456", "password", "123456789", "12345678", "12345",
                    "1234567", "admin", "123123", "qwerty", "abc123"
                ],
                "detection": "Successful login with weak password",
                "remediation": "Enforce strong password policy, use password strength meter"
            },
            "session_hijacking": {
                "severity": "CRITICAL",
                "owasp_id": "A07:2021",
                "category": "Identification and Authentication Failures",
                "detection": "Session fixation, predictable session IDs",
                "remediation": "Regenerate session ID after login, use secure cookies"
            },
            "insecure_headers": {
                "severity": "MEDIUM",
                "owasp_id": "A05:2021",
                "category": "Security Misconfiguration",
                "required_headers": [
                    "X-Frame-Options",
                    "X-Content-Type-Options",
                    "Strict-Transport-Security",
                    "Content-Security-Policy"
                ],
                "remediation": "Configure security headers properly"
            }
        }

    def test_sql_injection(self, endpoints: List[str]) -> Dict[str, Any]:
        """Testa SQL Injection em endpoints"""
        print(f"\n游댌 Testando SQL Injection em {len(endpoints)} endpoint(s)...")
        
        vulnerabilities = []
        payloads = self.vulnerability_db['sql_injection']['payloads']
        
        for endpoint in endpoints:
            for payload in payloads:
                # Simula칞칚o de teste (em produ칞칚o usaria requests)
                result = {
                    'endpoint': endpoint,
                    'payload': payload,
                    'vulnerable': False,  # Placeholder
                    'evidence': None
                }
                
                # Aqui seria feito o teste real
                # response = requests.get(endpoint, params={'id': payload})
                # if 'error' in response.text or 'SQL' in response.text:
                #     result['vulnerable'] = True
                
                if result['vulnerable']:
                    vulnerabilities.append(result)
        
        return {
            'test': 'sql_injection',
            'severity': self.vulnerability_db['sql_injection']['severity'],
            'tested_endpoints': len(endpoints),
            'vulnerabilities_found': len(vulnerabilities),
            'details': vulnerabilities
        }

    def test_xss(self, inputs: List[str]) -> Dict[str, Any]:
        """Testa XSS em inputs"""
        print(f"\n游댌 Testando XSS em {len(inputs)} input(s)...")
        
        vulnerabilities = []
        payloads = self.vulnerability_db['xss']['payloads']
        
        for input_field in inputs:
            for payload in payloads:
                # Simula칞칚o de teste
                result = {
                    'input': input_field,
                    'payload': payload,
                    'vulnerable': False,
                    'type': None  # reflected, stored, dom
                }
                
                # Aqui seria feito o teste real com Selenium
                # driver.find_element_by_id(input_field).send_keys(payload)
                # if payload in driver.page_source:
                #     result['vulnerable'] = True
                
                if result['vulnerable']:
                    vulnerabilities.append(result)
        
        return {
            'test': 'xss',
            'severity': self.vulnerability_db['xss']['severity'],
            'tested_inputs': len(inputs),
            'vulnerabilities_found': len(vulnerabilities),
            'details': vulnerabilities
        }

    def test_weak_passwords(self, login_endpoint: str, usernames: List[str]) -> Dict[str, Any]:
        """Testa senhas fracas"""
        print(f"\n游댌 Testando senhas fracas para {len(usernames)} usu치rio(s)...")
        
        weak_accounts = []
        common_passwords = self.vulnerability_db['weak_passwords']['common_passwords']
        
        for username in usernames:
            for password in common_passwords:
                # Simula칞칚o de teste
                result = {
                    'username': username,
                    'password': password,
                    'success': False
                }
                
                # Aqui seria feito o teste real
                # response = requests.post(login_endpoint, data={
                #     'username': username,
                #     'password': password
                # })
                # if response.status_code == 200:
                #     result['success'] = True
                
                if result['success']:
                    weak_accounts.append(result)
                    break  # Parar ap칩s encontrar senha fraca
        
        return {
            'test': 'weak_passwords',
            'severity': self.vulnerability_db['weak_passwords']['severity'],
            'tested_accounts': len(usernames),
            'weak_accounts_found': len(weak_accounts),
            'details': weak_accounts
        }

    def test_security_headers(self) -> Dict[str, Any]:
        """Testa headers de seguran칞a"""
        print(f"\n游댌 Testando headers de seguran칞a...")
        
        required_headers = self.vulnerability_db['insecure_headers']['required_headers']
        missing_headers = []
        
        # Simula칞칚o de teste
        # response = requests.get(self.target)
        # for header in required_headers:
        #     if header not in response.headers:
        #         missing_headers.append(header)
        
        # Placeholder
        missing_headers = ['X-Frame-Options', 'Content-Security-Policy']
        
        return {
            'test': 'security_headers',
            'severity': self.vulnerability_db['insecure_headers']['severity'],
            'required_headers': len(required_headers),
            'missing_headers': len(missing_headers),
            'details': missing_headers
        }

    def run_all_tests(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Executa todos os testes de seguran칞a"""
        print(f"\n{'='*60}")
        print(f"游 PENTESTING AGENT - Testes de Seguran칞a")
        print(f"{'='*60}")
        print(f"Target: {self.target}")
        print(f"Timestamp: {datetime.now().isoformat()}")
        
        results = {
            'target': self.target,
            'timestamp': datetime.now().isoformat(),
            'tests': []
        }
        
        # SQL Injection
        if config.get('test_sql_injection', True):
            sql_result = self.test_sql_injection(config.get('endpoints', ['/api/users']))
            results['tests'].append(sql_result)
        
        # XSS
        if config.get('test_xss', True):
            xss_result = self.test_xss(config.get('inputs', ['username', 'email', 'comment']))
            results['tests'].append(xss_result)
        
        # Weak Passwords
        if config.get('test_passwords', True):
            pwd_result = self.test_weak_passwords(
                config.get('login_endpoint', '/api/login'),
                config.get('usernames', ['admin', 'user', 'test'])
            )
            results['tests'].append(pwd_result)
        
        # Security Headers
        if config.get('test_headers', True):
            headers_result = self.test_security_headers()
            results['tests'].append(headers_result)
        
        # Calcular resumo
        total_vulnerabilities = sum(test.get('vulnerabilities_found', 0) for test in results['tests'])
        critical_count = sum(1 for test in results['tests'] if test.get('severity') == 'CRITICAL' and test.get('vulnerabilities_found', 0) > 0)
        
        results['summary'] = {
            'total_tests': len(results['tests']),
            'total_vulnerabilities': total_vulnerabilities,
            'critical_vulnerabilities': critical_count,
            'status': 'VULNERABLE' if total_vulnerabilities > 0 else 'SECURE'
        }
        
        # Salvar na mem칩ria
        self.save_to_memory(results)
        
        return results

    def save_to_memory(self, results: Dict[str, Any]):
        """Salva resultados na mem칩ria"""
        memory_entry = {
            'id': f"{int(datetime.now().timestamp())}-{hash(self.target) % 10000}",
            'timestamp': results['timestamp'],
            'target': self.target,
            'total_vulnerabilities': results['summary']['total_vulnerabilities'],
            'status': results['summary']['status'],
            'details': results
        }
        
        # Salvar em successes ou failures
        if results['summary']['total_vulnerabilities'] == 0:
            filepath = os.path.join(self.memory_path, 'successes.json')
        else:
            filepath = os.path.join(self.memory_path, 'failures.json')
        
        try:
            with open(filepath, 'r') as f:
                memory = json.load(f)
        except:
            memory = []
        
        memory.append(memory_entry)
        
        with open(filepath, 'w') as f:
            json.dump(memory, f, indent=2)

    def generate_report(self, results: Dict[str, Any]) -> str:
        """Gera relat칩rio detalhado"""
        report = f"\n{'='*60}\n"
        report += f"游늵 RELAT칍RIO DE SEGURAN칂A\n"
        report += f"{'='*60}\n\n"
        
        report += f"游꿢 Target: {results['target']}\n"
        report += f"游늰 Data: {results['timestamp']}\n"
        report += f"游댌 Testes executados: {results['summary']['total_tests']}\n"
        report += f"丘멆잺  Vulnerabilidades encontradas: {results['summary']['total_vulnerabilities']}\n"
        report += f"游 Vulnerabilidades cr칤ticas: {results['summary']['critical_vulnerabilities']}\n"
        report += f"游늵 Status: {results['summary']['status']}\n\n"
        
        report += f"{'='*60}\n"
        report += f"DETALHES DOS TESTES\n"
        report += f"{'='*60}\n\n"
        
        for test in results['tests']:
            report += f"游댳 {test['test'].upper()}\n"
            report += f"   Severidade: {test.get('severity', 'N/A')}\n"
            report += f"   Vulnerabilidades: {test.get('vulnerabilities_found', 0)}\n\n"
        
        return report


def main():
    parser = argparse.ArgumentParser(description='Pentesting Agent - Testes de Seguran칞a')
    parser.add_argument('--target', required=True, help='URL do target')
    parser.add_argument('--config', help='Arquivo de configura칞칚o JSON')
    parser.add_argument('--output', help='Arquivo de sa칤da para relat칩rio')
    
    args = parser.parse_args()
    
    # Carregar configura칞칚o
    if args.config and os.path.exists(args.config):
        with open(args.config, 'r') as f:
            config = json.load(f)
    else:
        config = {
            'test_sql_injection': True,
            'test_xss': True,
            'test_passwords': True,
            'test_headers': True
        }
    
    # Executar testes
    agent = PentestingAgent(args.target)
    results = agent.run_all_tests(config)
    
    # Gerar relat칩rio
    report = agent.generate_report(results)
    print(report)
    
    # Salvar relat칩rio
    if args.output:
        with open(args.output, 'w') as f:
            f.write(report)
    
    # Retornar JSON para integra칞칚o
    print("\n" + json.dumps(results, indent=2))
    
    # Exit code baseado em vulnerabilidades
    sys.exit(1 if results['summary']['total_vulnerabilities'] > 0 else 0)


if __name__ == '__main__':
    main()
